{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"econ720/schedule720.html","text":"Modern Macro \u00b6 Aug-19 (Thu): Modern macro , Here we talk about methods: how to set up a general equilibrium model and characterize its equilibrium. Aug-24 (Tue): Sequential trading and Arrow-Debreu Overlapping Generations \u00b6 Aug-26 (Thu): Model Aug-31 (Tue): OLG model (continued) Sep-2 (Thu): Dynamics and steady state , example (not yet active), PS1 , due Sep-9 Sep-7 (Tue): Efficiency and Social Security , RQ (review questions, not to be handed in) Sep-9 (Thu): Bequests Sep-14 (Tue): Money in OLG models , PS2 , due Sep-21 Infinite Horizon, Discrete Time Models \u00b6 Sep-16 (Thu): The growth model Sep-21 (Tue): Dynamic programming Sep-23 (Thu): Competitive equilibrium , RQ , PS3 , due Oct-5 Sep-28 (Tue): Cash in advance models , RQ , PS4 , due Oct-12 Sep-30 (Thu): Two sector models , RQ , (Skipped this year), Example: Asset pricing , RQ , Dynamic programming theorems , Notes on Dynamic Programming Infinite Horizon, Continuous Time Models \u00b6 Oct-5 (Tue): Solow model Oct-14 (Thu): Optimal control Oct-19 (Tue): The growth model Oct-26 (Tue): Competitive equilibrium , Dynamics and phase diagrams (skipped this year), RQ Oct-28 (Thu): Money in the utility function , PS5 , due Nov-2 Nov-2 (Tue): Perpetual youth , Aggregation issues (skipped this year) Endogenous Growth \u00b6 Nov-4 (Thu): Endogenous growth: AK model , RQ , Phase diagram (skipped this year), Increasing varieties , RQ Nov-9 (Tue): Increasing varieties, part II Nov-11 (Thu): Knowledge spillovers and scale effects , PS6 , due Nov-16 Nov-16 (Tue): Quality ladders , Quality ladders with firm dynamics Stochastic Growth \u00b6 Nov-18 (Thu): Stochastic optimization , Dynamic programming -- we will not talk about this in class. Think of it as a simple user guide to the results that are out there. Nov-23 (Tue): Asset pricing , Extensions , RQ , PS7 , due never Nov-30 (Tue): Stochastic growth model , RQ","title":"Schedule720"},{"location":"econ720/schedule720.html#modern-macro","text":"Aug-19 (Thu): Modern macro , Here we talk about methods: how to set up a general equilibrium model and characterize its equilibrium. Aug-24 (Tue): Sequential trading and Arrow-Debreu","title":"Modern Macro"},{"location":"econ720/schedule720.html#overlapping-generations","text":"Aug-26 (Thu): Model Aug-31 (Tue): OLG model (continued) Sep-2 (Thu): Dynamics and steady state , example (not yet active), PS1 , due Sep-9 Sep-7 (Tue): Efficiency and Social Security , RQ (review questions, not to be handed in) Sep-9 (Thu): Bequests Sep-14 (Tue): Money in OLG models , PS2 , due Sep-21","title":"Overlapping Generations"},{"location":"econ720/schedule720.html#infinite-horizon-discrete-time-models","text":"Sep-16 (Thu): The growth model Sep-21 (Tue): Dynamic programming Sep-23 (Thu): Competitive equilibrium , RQ , PS3 , due Oct-5 Sep-28 (Tue): Cash in advance models , RQ , PS4 , due Oct-12 Sep-30 (Thu): Two sector models , RQ , (Skipped this year), Example: Asset pricing , RQ , Dynamic programming theorems , Notes on Dynamic Programming","title":"Infinite Horizon, Discrete Time Models"},{"location":"econ720/schedule720.html#infinite-horizon-continuous-time-models","text":"Oct-5 (Tue): Solow model Oct-14 (Thu): Optimal control Oct-19 (Tue): The growth model Oct-26 (Tue): Competitive equilibrium , Dynamics and phase diagrams (skipped this year), RQ Oct-28 (Thu): Money in the utility function , PS5 , due Nov-2 Nov-2 (Tue): Perpetual youth , Aggregation issues (skipped this year)","title":"Infinite Horizon, Continuous Time Models"},{"location":"econ720/schedule720.html#endogenous-growth","text":"Nov-4 (Thu): Endogenous growth: AK model , RQ , Phase diagram (skipped this year), Increasing varieties , RQ Nov-9 (Tue): Increasing varieties, part II Nov-11 (Thu): Knowledge spillovers and scale effects , PS6 , due Nov-16 Nov-16 (Tue): Quality ladders , Quality ladders with firm dynamics","title":"Endogenous Growth"},{"location":"econ720/schedule720.html#stochastic-growth","text":"Nov-18 (Thu): Stochastic optimization , Dynamic programming -- we will not talk about this in class. Think of it as a simple user guide to the results that are out there. Nov-23 (Tue): Asset pricing , Extensions , RQ , PS7 , due never Nov-30 (Tue): Stochastic growth model , RQ","title":"Stochastic Growth"},{"location":"julia_notes/types.html","text":"Types \u00b6 Parametric types without the type parameter are NOT DataTypes; they are UnionAll. Example: struct Foo{T} end; isa(Foo, DataType) == false; I find it easiest to write model specific code NOT using parametric types. Instead, I define type aliases for the types used in custom types (e.g., Double=Float64 ). Then I hardwire the use of Double everywhere. This removes two problems: Possible type instability as the compiler tries to figure out the types of the custom type fields. It becomes possible to call constructors with, say, integers of all kinds without raising method errors. Broadcasting (1.6) \u00b6 For an object that behaves like a scalar, such as struct Foo x :: Int end it is enough to define Base.broadcastable(f :: Foo) = Ref(f) . Constructors (1.5) \u00b6 Constructing objects with many fields: Define an inner constructor that leaves the object (partially) uninitialized. It is legal to have new(x) even if the object contains additional fields. LazyInitializedFields.jl ensures that accessing uninitialized fields gives errors. Parameters.jl is useful for objects with default values. Constructor must then provide all arguments that do not have defaults. Note that @with_kw automatically defines show(). Use @with_kw_noshow to avoid this. Base.@kwdef now does much of the same. Inheritance (1.5) \u00b6 There is no inheritance in Julia. Abstract types have no fields and concrete types have no subtypes. There are various discussions about how to implement types that share common fields. For simple cases, it is probably best to just repeat the fields in all types. One good piece of advice: ensure that methods are generally defined on the abstract type, so that all concrete types have the same interface (kind of the point of having an abstract type). Macro for common fields \u00b6 A macro that lets users define a set of common fields for a set of structs: macro def ( name , definition ) return quote macro $ ( esc ( name ))() esc ( $ ( Expr ( : quote , definition ))) end end end @def commonfields begin #Data X #Feature vectors y #Labels (-1,1) nSamples :: Int64 # Number of data points nFeatures :: Int64 # Number of features end struct Foo @commonfields z end But this does not work with default values. Another option using @eval . A more robust implementation is Mixers.jl . @mix is intended to create parametric types. But @mix C1{} [...] works as well and creates a plain vanilla type. However, the @pour macro is then simpler: julia > @pour c1 begin x :: Int y :: Float64 end @c1 ( macro with 1 method ) julia > struct Foo @c1 z :: String end julia > Foo ( 1 , 2.0 , \"abc\" ) Foo ( 1 , 2.0 , \"abc\" ) Common fields with default values \u00b6 mutable struct Foo x y z Foo () = new (); end # Need at least one positional argument. Otherwise stack overflow. function Foo ( z :: Integer ; kwargs ... ) f = Foo (); set_common_fields! ( f ); set_kw_args! ( f ; kwargs ... ); f . z = z ; return f end function set_common_fields! ( f :: Foo ) f . x = 1 ; f . y = 2 ; end function set_kw_args! ( f :: Foo ; kwargs ... ) for kw in kwargs setfield! ( f , kw [ 1 ], kw [ 2 ]) end end julia > Foo ( 3 ) Foo ( 1 , 2 , 3 ) Common fields in sub-struct \u00b6 An alternative is to store common fields in a sub-struct. Passing methods through to these fields can be automated using @forward in Lazy.jl . using Lazy struct Foo x end @forward Foo . x ( Base . show , Base . isempty ) The tricky part is to modify these fields. One possible solution: Base.@kwdef mutable struct FooCommon x = 1 y = 2 end Base.@kwdef mutable struct Foo fc :: FooCommon z = 3 zz = 4 end # Again: need at least one positional argument to avoid stack overflow. function Foo(z; kwargs...) f = Foo(fc = FooCommon()); set_kwargs!(f; kwargs...); return f end function set_kwargs!(f :: Foo; kwargs...) for kw in kwargs set_field!(f, kw[1], kw[2]); end end # Note the changed function name. Cannot overload `setfield!`. function set_field!(f :: Foo, fName :: Symbol, fValue) if hasproperty(f, fName) setfield!(f, fName, fValue); else setfield!(f.fc, fName, fValue); end end User Defined Types (1.5) \u00b6 LazyInitializedFields.jl is a nice way of handling partially initialized struct fields. Properties and fields \u00b6 getfield is a \"built-in\" function that always points to a struct field directly. Example: struct A x :: Dict { Symbol , Int } y :: Int end a = A ( Dict ([ : a => 1 ]), 2 ); getfield ( a , : x ) isa Dict { Symbol , Int } getproperty is generically the same as getfield . But note that propertynames(A) spits out additional hidden properties, not just :x, :y . Users can overload getproperty to point to something more useful than the direct fields of the struct : Base . getproperty ( a :: A , n :: Symbol ) = getfield ( a , : x )[ n ]; Then also overload propertynames so that functions that rely on the public properties of A work.","title":"Types"},{"location":"julia_notes/types.html#types","text":"Parametric types without the type parameter are NOT DataTypes; they are UnionAll. Example: struct Foo{T} end; isa(Foo, DataType) == false; I find it easiest to write model specific code NOT using parametric types. Instead, I define type aliases for the types used in custom types (e.g., Double=Float64 ). Then I hardwire the use of Double everywhere. This removes two problems: Possible type instability as the compiler tries to figure out the types of the custom type fields. It becomes possible to call constructors with, say, integers of all kinds without raising method errors.","title":"Types"},{"location":"julia_notes/types.html#broadcasting-16","text":"For an object that behaves like a scalar, such as struct Foo x :: Int end it is enough to define Base.broadcastable(f :: Foo) = Ref(f) .","title":"Broadcasting (1.6)"},{"location":"julia_notes/types.html#constructors-15","text":"Constructing objects with many fields: Define an inner constructor that leaves the object (partially) uninitialized. It is legal to have new(x) even if the object contains additional fields. LazyInitializedFields.jl ensures that accessing uninitialized fields gives errors. Parameters.jl is useful for objects with default values. Constructor must then provide all arguments that do not have defaults. Note that @with_kw automatically defines show(). Use @with_kw_noshow to avoid this. Base.@kwdef now does much of the same.","title":"Constructors (1.5)"},{"location":"julia_notes/types.html#inheritance-15","text":"There is no inheritance in Julia. Abstract types have no fields and concrete types have no subtypes. There are various discussions about how to implement types that share common fields. For simple cases, it is probably best to just repeat the fields in all types. One good piece of advice: ensure that methods are generally defined on the abstract type, so that all concrete types have the same interface (kind of the point of having an abstract type).","title":"Inheritance (1.5)"},{"location":"julia_notes/types.html#macro-for-common-fields","text":"A macro that lets users define a set of common fields for a set of structs: macro def ( name , definition ) return quote macro $ ( esc ( name ))() esc ( $ ( Expr ( : quote , definition ))) end end end @def commonfields begin #Data X #Feature vectors y #Labels (-1,1) nSamples :: Int64 # Number of data points nFeatures :: Int64 # Number of features end struct Foo @commonfields z end But this does not work with default values. Another option using @eval . A more robust implementation is Mixers.jl . @mix is intended to create parametric types. But @mix C1{} [...] works as well and creates a plain vanilla type. However, the @pour macro is then simpler: julia > @pour c1 begin x :: Int y :: Float64 end @c1 ( macro with 1 method ) julia > struct Foo @c1 z :: String end julia > Foo ( 1 , 2.0 , \"abc\" ) Foo ( 1 , 2.0 , \"abc\" )","title":"Macro for common fields"},{"location":"julia_notes/types.html#common-fields-with-default-values","text":"mutable struct Foo x y z Foo () = new (); end # Need at least one positional argument. Otherwise stack overflow. function Foo ( z :: Integer ; kwargs ... ) f = Foo (); set_common_fields! ( f ); set_kw_args! ( f ; kwargs ... ); f . z = z ; return f end function set_common_fields! ( f :: Foo ) f . x = 1 ; f . y = 2 ; end function set_kw_args! ( f :: Foo ; kwargs ... ) for kw in kwargs setfield! ( f , kw [ 1 ], kw [ 2 ]) end end julia > Foo ( 3 ) Foo ( 1 , 2 , 3 )","title":"Common fields with default values"},{"location":"julia_notes/types.html#common-fields-in-sub-struct","text":"An alternative is to store common fields in a sub-struct. Passing methods through to these fields can be automated using @forward in Lazy.jl . using Lazy struct Foo x end @forward Foo . x ( Base . show , Base . isempty ) The tricky part is to modify these fields. One possible solution: Base.@kwdef mutable struct FooCommon x = 1 y = 2 end Base.@kwdef mutable struct Foo fc :: FooCommon z = 3 zz = 4 end # Again: need at least one positional argument to avoid stack overflow. function Foo(z; kwargs...) f = Foo(fc = FooCommon()); set_kwargs!(f; kwargs...); return f end function set_kwargs!(f :: Foo; kwargs...) for kw in kwargs set_field!(f, kw[1], kw[2]); end end # Note the changed function name. Cannot overload `setfield!`. function set_field!(f :: Foo, fName :: Symbol, fValue) if hasproperty(f, fName) setfield!(f, fName, fValue); else setfield!(f.fc, fName, fValue); end end","title":"Common fields in sub-struct"},{"location":"julia_notes/types.html#user-defined-types-15","text":"LazyInitializedFields.jl is a nice way of handling partially initialized struct fields.","title":"User Defined Types (1.5)"},{"location":"julia_notes/types.html#properties-and-fields","text":"getfield is a \"built-in\" function that always points to a struct field directly. Example: struct A x :: Dict { Symbol , Int } y :: Int end a = A ( Dict ([ : a => 1 ]), 2 ); getfield ( a , : x ) isa Dict { Symbol , Int } getproperty is generically the same as getfield . But note that propertynames(A) spits out additional hidden properties, not just :x, :y . Users can overload getproperty to point to something more useful than the direct fields of the struct : Base . getproperty ( a :: A , n :: Symbol ) = getfield ( a , : x )[ n ]; Then also overload propertynames so that functions that rely on the public properties of A work.","title":"Properties and fields"}]}