{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"econ890/julia/code_loading.html","text":"Code Loading \u00b6 When you write a file with some code, how does Julia know where to find it? From the REPL include(/path/to/file.jl) does the trick. This has the same effect as typing the code in the REPL. The same can be done inside another file. But what if you have a big chunk of code that you want to be reusable? What if you want to use someone else's code? This is where packages come into play. The LOAD_PATH \u00b6 You can also load modules that are not packaged as packages by putting their directories into the LOAD_PATH environment variable. We will not use this approach. It is easier to package everything as a package instead.","title":"Code Loading"},{"location":"econ890/julia/code_loading.html#code-loading","text":"When you write a file with some code, how does Julia know where to find it? From the REPL include(/path/to/file.jl) does the trick. This has the same effect as typing the code in the REPL. The same can be done inside another file. But what if you have a big chunk of code that you want to be reusable? What if you want to use someone else's code? This is where packages come into play.","title":"Code Loading"},{"location":"econ890/julia/code_loading.html#the-load_path","text":"You can also load modules that are not packaged as packages by putting their directories into the LOAD_PATH environment variable. We will not use this approach. It is easier to package everything as a package instead.","title":"The LOAD_PATH"},{"location":"econ890/julia/outline.html","text":"Julia for Economists \u00b6 Our approach will be to compute a version of the classic Huggett (1996) model. We will start simple, but eventually (time permitting) get to the point where our code will be well structured, reusable, and tested. Table of Contents \u00b6 Basics \u00b6 Getting started Types and variables Functions Writing solid code Object oriented programming Packages Testing Solving a Permanent Income Model \u00b6 Simple minded approach OOP approach Shooting approach","title":"Julia for Economists"},{"location":"econ890/julia/outline.html#julia-for-economists","text":"Our approach will be to compute a version of the classic Huggett (1996) model. We will start simple, but eventually (time permitting) get to the point where our code will be well structured, reusable, and tested.","title":"Julia for Economists"},{"location":"econ890/julia/outline.html#table-of-contents","text":"","title":"Table of Contents"},{"location":"econ890/julia/outline.html#basics","text":"Getting started Types and variables Functions Writing solid code Object oriented programming Packages Testing","title":"Basics"},{"location":"econ890/julia/outline.html#solving-a-permanent-income-model","text":"Simple minded approach OOP approach Shooting approach","title":"Solving a Permanent Income Model"},{"location":"econ890/julia/packages.html","text":"Packages \u00b6 A package is a directory with code that declares all of its dependencies. It is self-contained. A package is a type of \"environment\". Environments \u00b6 This is a key concept for Julia! At any point in time, Julia activates one directory as the active environment. This determines which packages (think code libraries) can be loaded with using MyPackage . To keep track of what is visible, the directory that contains a file Project.toml file. This file declares all of the available packages, their versions, and their locations. When you start Julia, you are in the v1.5 environment (replace the 1.5 with the Julia version that you are using). Tip: keep this environment minimal. Here you just want to list packages that you use while developing your code (e.g. Revise.jl ). If you look at Project.toml , you see something like: shell> cat ~/.julia/environments/v1.6/Project.toml [deps] OhMyREPL = \"5fb14364-9ced-5910-84b2-373655c76a03\" Revise = \"295af30f-e4ad-537b-8983-00126c2a3abe\" Each line gives the name and UUID (a unique id) of each available package. An easier way of seeing the same info: julia> using Pkg julia> Pkg.status() Status `~/.julia/environments/v1.5/Project.toml` [5fb14364] OhMyREPL v0.5.10 [295af30f] Revise v3.1.12 This means that using Revise will make the code in Revise.jl available. But if I try using Plots , I get an error message: julia> using Plots ERROR: ArgumentError: Package Plots not found in current path: - Run `import Pkg; Pkg.add(\"Plots\")` to install the Plots package. This basically says: Julia cannot find an entry for Plots in Project.toml . So the code cannot be used until I run Pkg.add(\"Plots\") . If you now activate a different directory using Pkg.activate(\"/path/to/dir\") , additional packages become available. Note that the packages known from v1.5 are not \"forgotten.\" Each time I activate a new environment, packages get added to the known list of loadable packages. This is known as stacked environments . They are stacked in the sense that activating another environment retains the packages that are already activated. This is the reason why you want your v.1.5 environment to be minimal. The Registry \u00b6 Packages are often registered: the authors create an entry in the Julia General Registry for their package. If this is the case, Pkg.add(\"Revise\") works. Julia looks up the most recent version in the registry and downloads the code from a github repo. The code goes into a hidden directory in .julia/packages . Each version of Revise that you ever use gets stored there. You rarely need to worry about where this code lives. If a package is not registered, presumably because you wrote it yourself, using it gets a bit more complicated. A good approach is to create your own local registry (using LocalRegistry.jl ). Then your not officially registered packages are treated like registered ones. For starter purposes, the alternative is to develop your packages instead with Pkg.develop(/path/to/MyPackage) . What does this do? It simply adds an entry in Project.toml that links the package name MyPackage to the directory where the code can be found. There is one fundamental difference between add and develop . add fixes the version of the package until you manually Pkg.update(\"MyPackage\") . Even if the developer changes the code, the version that you are using remains unchanged. develop tells Julia to track whatever code changes happen in the directory where the package code resides (the one you provide with the develop command). Packages \u00b6 So, what is a package? It really is a special case of an environment that satisfies some additional criteria (e.g., a specific directory structure is present). One expectation is that src/MyPackage.jl defines the module MyPackage plus types and functions. To use a package, write using MyPackage and voila - all the types and functions defined in MyPackage are available in your code, including the code MyPackage requires from other packages. Dependency Hell \u00b6 So, you create an environment and add packages A and B . Both A and B depend on X and Y , but X also depends on Y . But when different people wrote A , B , and X they were using different versions of Y (and perhaps also of X ). How can the resulting code possibly run successfully? This problem is called \"dependency hell\". The solution relies on meaningful version numbers together with explicity compatibility specifications. Version numbers (at least for registered packages) have precise meaning. Minor version bumps (e.g. from 1.4 to 1.5 ) are expected to be non-breaking . They can add features, but not change the existing API. This is called semantic versioning and it is the cornerstone of decentralized software development. Each package's Project.toml contains a [compat] section that specifies the versions of all packages that are compatible. The package manager's job is to combine the Project.toml s of all packages used (directly or indirectly) and to figure out a combination of version numbers that satisfies all compatibility requirements. One might expect that this could never work in a project that uses dozens of packages, but, surprisingly, it generally works out just fine.","title":"Packages"},{"location":"econ890/julia/packages.html#packages","text":"A package is a directory with code that declares all of its dependencies. It is self-contained. A package is a type of \"environment\".","title":"Packages"},{"location":"econ890/julia/packages.html#environments","text":"This is a key concept for Julia! At any point in time, Julia activates one directory as the active environment. This determines which packages (think code libraries) can be loaded with using MyPackage . To keep track of what is visible, the directory that contains a file Project.toml file. This file declares all of the available packages, their versions, and their locations. When you start Julia, you are in the v1.5 environment (replace the 1.5 with the Julia version that you are using). Tip: keep this environment minimal. Here you just want to list packages that you use while developing your code (e.g. Revise.jl ). If you look at Project.toml , you see something like: shell> cat ~/.julia/environments/v1.6/Project.toml [deps] OhMyREPL = \"5fb14364-9ced-5910-84b2-373655c76a03\" Revise = \"295af30f-e4ad-537b-8983-00126c2a3abe\" Each line gives the name and UUID (a unique id) of each available package. An easier way of seeing the same info: julia> using Pkg julia> Pkg.status() Status `~/.julia/environments/v1.5/Project.toml` [5fb14364] OhMyREPL v0.5.10 [295af30f] Revise v3.1.12 This means that using Revise will make the code in Revise.jl available. But if I try using Plots , I get an error message: julia> using Plots ERROR: ArgumentError: Package Plots not found in current path: - Run `import Pkg; Pkg.add(\"Plots\")` to install the Plots package. This basically says: Julia cannot find an entry for Plots in Project.toml . So the code cannot be used until I run Pkg.add(\"Plots\") . If you now activate a different directory using Pkg.activate(\"/path/to/dir\") , additional packages become available. Note that the packages known from v1.5 are not \"forgotten.\" Each time I activate a new environment, packages get added to the known list of loadable packages. This is known as stacked environments . They are stacked in the sense that activating another environment retains the packages that are already activated. This is the reason why you want your v.1.5 environment to be minimal.","title":"Environments"},{"location":"econ890/julia/packages.html#the-registry","text":"Packages are often registered: the authors create an entry in the Julia General Registry for their package. If this is the case, Pkg.add(\"Revise\") works. Julia looks up the most recent version in the registry and downloads the code from a github repo. The code goes into a hidden directory in .julia/packages . Each version of Revise that you ever use gets stored there. You rarely need to worry about where this code lives. If a package is not registered, presumably because you wrote it yourself, using it gets a bit more complicated. A good approach is to create your own local registry (using LocalRegistry.jl ). Then your not officially registered packages are treated like registered ones. For starter purposes, the alternative is to develop your packages instead with Pkg.develop(/path/to/MyPackage) . What does this do? It simply adds an entry in Project.toml that links the package name MyPackage to the directory where the code can be found. There is one fundamental difference between add and develop . add fixes the version of the package until you manually Pkg.update(\"MyPackage\") . Even if the developer changes the code, the version that you are using remains unchanged. develop tells Julia to track whatever code changes happen in the directory where the package code resides (the one you provide with the develop command).","title":"The Registry"},{"location":"econ890/julia/packages.html#packages_1","text":"So, what is a package? It really is a special case of an environment that satisfies some additional criteria (e.g., a specific directory structure is present). One expectation is that src/MyPackage.jl defines the module MyPackage plus types and functions. To use a package, write using MyPackage and voila - all the types and functions defined in MyPackage are available in your code, including the code MyPackage requires from other packages.","title":"Packages"},{"location":"econ890/julia/packages.html#dependency-hell","text":"So, you create an environment and add packages A and B . Both A and B depend on X and Y , but X also depends on Y . But when different people wrote A , B , and X they were using different versions of Y (and perhaps also of X ). How can the resulting code possibly run successfully? This problem is called \"dependency hell\". The solution relies on meaningful version numbers together with explicity compatibility specifications. Version numbers (at least for registered packages) have precise meaning. Minor version bumps (e.g. from 1.4 to 1.5 ) are expected to be non-breaking . They can add features, but not change the existing API. This is called semantic versioning and it is the cornerstone of decentralized software development. Each package's Project.toml contains a [compat] section that specifies the versions of all packages that are compatible. The package manager's job is to combine the Project.toml s of all packages used (directly or indirectly) and to figure out a combination of version numbers that satisfies all compatibility requirements. One might expect that this could never work in a project that uses dozens of packages, but, surprisingly, it generally works out just fine.","title":"Dependency Hell"},{"location":"econ890/julia/pih/pih2.html","text":"Solving a Permanent Income Model: OOP Approach \u00b6 Our insight so far: hard-wiring functional forms does not work. How can we build a more flexible model? One approach: define a Model object it contains the fixed parameters \\(T\\) , \\(R\\) , \\(Y\\) plus another object that specifies preferences and their parameters Then we can: init the model with the right preferences and parameters just pass the Model around (not the collection of parameters) Factoring out Preferences \u00b6 Utility functions are not model specific (certainly not in this case). It would make sense to factor out all of the code that does utility calculations. Then we can: easily reuse that code in other projects test that code independently of everything else ensure that eacy utility function supports the same interface, so they can be easily swapped in and out. What do we want utility functions to do? compute \\(u(c)\\) and \\(u'(c)\\) it is often also useful to know inverse marginal utility compute the growth rate of \\(c\\) and (related) Euler equation deviations This defines the API that is visible to the outside world and common to all utility functions. Note: If we were a bit more serious, we would think about embedding all of this into a bigger set of utility functions that depend on multiple arguments. Let's start with log utility. Log has no parameters, so we have struct UtilityLog end But for CRRA we have struct UtilityCRRA sigma :: Float64 end Note: We generally would not want to hard-wire that sigma is a Float64 . More generic would be a parametric type : struct UtilityCRRA{T} sigma :: T end But we keep things simple for now. Since we are packaging the code, we should really put it into a module (or better: a package). But we defer this as well for later. Exercise: write code for the utility functions. My solution Exercise: write tests for the utility functions. My solution Making a Model \u00b6 Now we easily build a Model from its parts. struct Model Y :: Float64 R :: Float64 T :: Int beta :: Float64 u :: AbstractUtility end m = Model(10.0, 1.04, 30, 0.98, UtilityLog()); Note: switching out the utility function is now trivial adding new utility functions is just as trivial the code does not contain any if utilityLog type switches Exercise: Write this code - and don't forget the tests. My solution and the tests I packaged everything in modules because: eventually, this should go into a package (therefore into a module) once we define structs , we cannot repeatedly include the code (invalid redefinition of the struct) the module makes sure that we don't have side-effects.","title":"Solving a Permanent Income Model: OOP Approach"},{"location":"econ890/julia/pih/pih2.html#solving-a-permanent-income-model-oop-approach","text":"Our insight so far: hard-wiring functional forms does not work. How can we build a more flexible model? One approach: define a Model object it contains the fixed parameters \\(T\\) , \\(R\\) , \\(Y\\) plus another object that specifies preferences and their parameters Then we can: init the model with the right preferences and parameters just pass the Model around (not the collection of parameters)","title":"Solving a Permanent Income Model: OOP Approach"},{"location":"econ890/julia/pih/pih2.html#factoring-out-preferences","text":"Utility functions are not model specific (certainly not in this case). It would make sense to factor out all of the code that does utility calculations. Then we can: easily reuse that code in other projects test that code independently of everything else ensure that eacy utility function supports the same interface, so they can be easily swapped in and out. What do we want utility functions to do? compute \\(u(c)\\) and \\(u'(c)\\) it is often also useful to know inverse marginal utility compute the growth rate of \\(c\\) and (related) Euler equation deviations This defines the API that is visible to the outside world and common to all utility functions. Note: If we were a bit more serious, we would think about embedding all of this into a bigger set of utility functions that depend on multiple arguments. Let's start with log utility. Log has no parameters, so we have struct UtilityLog end But for CRRA we have struct UtilityCRRA sigma :: Float64 end Note: We generally would not want to hard-wire that sigma is a Float64 . More generic would be a parametric type : struct UtilityCRRA{T} sigma :: T end But we keep things simple for now. Since we are packaging the code, we should really put it into a module (or better: a package). But we defer this as well for later. Exercise: write code for the utility functions. My solution Exercise: write tests for the utility functions. My solution","title":"Factoring out Preferences"},{"location":"econ890/julia/pih/pih2.html#making-a-model","text":"Now we easily build a Model from its parts. struct Model Y :: Float64 R :: Float64 T :: Int beta :: Float64 u :: AbstractUtility end m = Model(10.0, 1.04, 30, 0.98, UtilityLog()); Note: switching out the utility function is now trivial adding new utility functions is just as trivial the code does not contain any if utilityLog type switches Exercise: Write this code - and don't forget the tests. My solution and the tests I packaged everything in modules because: eventually, this should go into a package (therefore into a module) once we define structs , we cannot repeatedly include the code (invalid redefinition of the struct) the module makes sure that we don't have side-effects.","title":"Making a Model"},{"location":"econ890/julia/pih/pih3.html","text":"Permanent Income Model 3: Shooting \u00b6 Generalize the model to non-homothetic preferences. Now \\(g(c)\\) depends on \\(c\\) . There is no closed-form solution. Algorithm: Shooting \u00b6 Search over values for \\(c_{T}\\) . For each: Compute \\(c_t\\) from the Euler equation (backwards). Compute the present value of consumption. Check the lifetime budget constraint. Interpolation \u00b6 A simple way of finding the optimal \\(c_T\\) : Compute the present value of consumption on a grid of \\(c_T\\) . Interpolate between grid points to find the value that satisfies the budget constraint. Exercise: write this code - and don't forget the tests In my solution , the interpolation is simply hand coded. Usually, one would use a package for this (such as Interpolations.jl ). Interpolation is, of course, inefficient. We need to compute a large number of grid points for \\(c_T\\) . A better solution is to use a numerical optimizer. Solving this model is an example of root finding. We are looking for the solution to \\(f(c_T)=0\\) . There are various libraries that offer algorithms for root finding and for the more common problem of minimizing a function. Using these libraries requires that we install packages . In this case, we will use Roots.jl . See root finding . find_zero finds the root of a function f(x) . This is what we will use. Excercise: write this code. My solution with test","title":"Permanent Income Model 3: Shooting"},{"location":"econ890/julia/pih/pih3.html#permanent-income-model-3-shooting","text":"Generalize the model to non-homothetic preferences. Now \\(g(c)\\) depends on \\(c\\) . There is no closed-form solution.","title":"Permanent Income Model 3: Shooting"},{"location":"econ890/julia/pih/pih3.html#algorithm-shooting","text":"Search over values for \\(c_{T}\\) . For each: Compute \\(c_t\\) from the Euler equation (backwards). Compute the present value of consumption. Check the lifetime budget constraint.","title":"Algorithm: Shooting"},{"location":"econ890/julia/pih/pih3.html#interpolation","text":"A simple way of finding the optimal \\(c_T\\) : Compute the present value of consumption on a grid of \\(c_T\\) . Interpolate between grid points to find the value that satisfies the budget constraint. Exercise: write this code - and don't forget the tests In my solution , the interpolation is simply hand coded. Usually, one would use a package for this (such as Interpolations.jl ). Interpolation is, of course, inefficient. We need to compute a large number of grid points for \\(c_T\\) . A better solution is to use a numerical optimizer. Solving this model is an example of root finding. We are looking for the solution to \\(f(c_T)=0\\) . There are various libraries that offer algorithms for root finding and for the more common problem of minimizing a function. Using these libraries requires that we install packages . In this case, we will use Roots.jl . See root finding . find_zero finds the root of a function f(x) . This is what we will use. Excercise: write this code. My solution with test","title":"Interpolation"},{"location":"econ890/julia/pih/pih4.html","text":"Permanent Income Model 4: Value Function Iteration \u00b6 Now we solve the model by backward induction. This is not efficient in this case, but gets us started on methods for the more general Huggett model. The math \u00b6 Bellman equation: \\[V(k,t)=\\max_{k'} U(w+rk-k') + \\beta V(k',t+1)\\] with first order condition \\[U'(w+rk-k')=\\beta V_{k}(k',t+1)\\] and envelope condition \\[V_{k}(k,t) = r U'(w + rk - k')\\] Value Function Iteration \u00b6 Start at \\(t = T\\) with \\[V(k,T) = U(w+rk)\\] Set up a grid for \\(k\\) . For each \\(k\\) on the grid: maximize \\(U(w+rk-k') + \\beta V(k',t+1)\\) by searching over \\(k'\\) this gives \\(k'=G(k,t)\\) compute \\(V(k,t) = U(w+rk-G(k,t)) + \\beta V(G(k,t), t+1)\\) Problem: We need to evaluate \\(V(k',t+1)\\) off the grid. Solution: Interpolation (below). This is inefficient it involves a numerical maximization for each \\(k\\) grid point it is much easier (numerically) to find a root than to maximize a function Approximate \\(V_{k}(k,t)\\) \u00b6 Start at \\(t=T\\) with \\[V_{k}(k,T)=U'(w+rk-k')\\] Set up a grid for \\(k\\) . For each \\(k\\) on the grid: Search for the root of \\(U'(w+rk-k')-\\beta V_{k}(k',t+1)\\) Compute the decision rule \\(k' = G(k,t)\\) Compute \\(V_{k}(k,t) = r U'(w + rk - G(k,t))\\) Problem: We have \\(V_{k}\\) on the grid, but for the root finding we need \\(V_{k}\\) off the grid. Solution: Construct a function that approximates \\(V_{k}\\) based on the grid points that we have computed. Problem: \\(V_{k}\\) is highly nonlinear, so it is hard to approximate. Solution: Restate the FOC as \\(w+rk-k'=U'^{-1}(\\beta V_{k}(k',t+1))\\) . Approximate the RHS of this expression. Find the root of the corresponding deviation: \\(k'=G(k,t)\\) . Use this to compute \\(V_{k}(k,t)\\) on the grid. Policy Function Iteration \u00b6 We don't really care about \\(V\\) or \\(V_{k}\\) . All we need is \\(k'=G(k,t)\\) . So we approximate this directly. Start at \\(t=T\\) with \\(G(k,T) = 0\\) . Set up a grid for \\(k\\) . For each \\(k\\) on the grid: find the root of the Euler equation \\( \\(U'(w+rk-k') - \\beta R U'(w'+rk'-G(k', t+1))\\) \\) but better (not as non-linear): \\( \\(w+rk-k' - U'^{-1}(\\beta R U'(w'+rk'-G(k', t+1)))\\) \\) this gives \\(k'=G(k,t)\\) on the \\(k\\) grid. Again, we need to interpolate the policy function between grid points. Notes on root finding . Exercise: write this code","title":"Permanent Income Model 4: Value Function Iteration"},{"location":"econ890/julia/pih/pih4.html#permanent-income-model-4-value-function-iteration","text":"Now we solve the model by backward induction. This is not efficient in this case, but gets us started on methods for the more general Huggett model.","title":"Permanent Income Model 4: Value Function Iteration"},{"location":"econ890/julia/pih/pih4.html#the-math","text":"Bellman equation: \\[V(k,t)=\\max_{k'} U(w+rk-k') + \\beta V(k',t+1)\\] with first order condition \\[U'(w+rk-k')=\\beta V_{k}(k',t+1)\\] and envelope condition \\[V_{k}(k,t) = r U'(w + rk - k')\\]","title":"The math"},{"location":"econ890/julia/pih/pih4.html#value-function-iteration","text":"Start at \\(t = T\\) with \\[V(k,T) = U(w+rk)\\] Set up a grid for \\(k\\) . For each \\(k\\) on the grid: maximize \\(U(w+rk-k') + \\beta V(k',t+1)\\) by searching over \\(k'\\) this gives \\(k'=G(k,t)\\) compute \\(V(k,t) = U(w+rk-G(k,t)) + \\beta V(G(k,t), t+1)\\) Problem: We need to evaluate \\(V(k',t+1)\\) off the grid. Solution: Interpolation (below). This is inefficient it involves a numerical maximization for each \\(k\\) grid point it is much easier (numerically) to find a root than to maximize a function","title":"Value Function Iteration"},{"location":"econ890/julia/pih/pih4.html#approximate-v_kkt","text":"Start at \\(t=T\\) with \\[V_{k}(k,T)=U'(w+rk-k')\\] Set up a grid for \\(k\\) . For each \\(k\\) on the grid: Search for the root of \\(U'(w+rk-k')-\\beta V_{k}(k',t+1)\\) Compute the decision rule \\(k' = G(k,t)\\) Compute \\(V_{k}(k,t) = r U'(w + rk - G(k,t))\\) Problem: We have \\(V_{k}\\) on the grid, but for the root finding we need \\(V_{k}\\) off the grid. Solution: Construct a function that approximates \\(V_{k}\\) based on the grid points that we have computed. Problem: \\(V_{k}\\) is highly nonlinear, so it is hard to approximate. Solution: Restate the FOC as \\(w+rk-k'=U'^{-1}(\\beta V_{k}(k',t+1))\\) . Approximate the RHS of this expression. Find the root of the corresponding deviation: \\(k'=G(k,t)\\) . Use this to compute \\(V_{k}(k,t)\\) on the grid.","title":"Approximate \\(V_{k}(k,t)\\)"},{"location":"econ890/julia/pih/pih4.html#policy-function-iteration","text":"We don't really care about \\(V\\) or \\(V_{k}\\) . All we need is \\(k'=G(k,t)\\) . So we approximate this directly. Start at \\(t=T\\) with \\(G(k,T) = 0\\) . Set up a grid for \\(k\\) . For each \\(k\\) on the grid: find the root of the Euler equation \\( \\(U'(w+rk-k') - \\beta R U'(w'+rk'-G(k', t+1))\\) \\) but better (not as non-linear): \\( \\(w+rk-k' - U'^{-1}(\\beta R U'(w'+rk'-G(k', t+1)))\\) \\) this gives \\(k'=G(k,t)\\) on the \\(k\\) grid. Again, we need to interpolate the policy function between grid points. Notes on root finding . Exercise: write this code","title":"Policy Function Iteration"},{"location":"econ890/julia/pih/root_finding.html","text":"Root Finding \u00b6 Root finding means finding the zero of a function, i.e., find \\(x^*\\) such that \\(f(x^*) = 0\\) . For this type of problem, we use code packaged into reusable libraries, called \"packages\". See the Section on Packages . In this case, we will use Roots.jl . Before we can use Roots , we need to add it as a dependency to the current environment : julia> cd(\"/Users/lutz/Documents/data/web/professional/docs/econ890/julia/\") (@v1.5) pkg> activate . Activating new environment at `~/Documents/data/web/professional/docs/econ890/julia/Project.toml` We have now activated the environment described by Project.toml in this directory. To get the Pkg commands to work, type ] and the pkg> prompt appears. Backspace backs out of the Pkg mode in the REPL. To see which packages are already contained in the enviroment: (julia) pkg> st Status `~/Documents/data/web/professional/docs/econ890/julia/Project.toml` (empty project) This makes sense; we have not added any packages yet. But keep in mind that everything we activated before (including all packages in your v1.5 environment are still available). Let's add Roots : (julia) pkg> add Roots Updating registry at `~/.julia/registries/General` ######################################################################## 100.0% Updating registry at `~/.julia/registries/registryLH` Updating git-repo `https://github.com/hendri54/registryLH` Resolving package versions... Updating `~/Documents/data/web/professional/docs/econ890/julia/Project.toml` [f2b01f46] + Roots v1.0.8 Updating `~/Documents/data/web/professional/docs/econ890/julia/Manifest.toml` [f2b01f46] + Roots v1.0.8 [de0858da] + Printf [4ec0a83e] + Unicode (julia) pkg> st Status `~/Documents/data/web/professional/docs/econ890/julia/Project.toml` [f2b01f46] Roots v1.0.8 Now using Roots works. Roots is a registered package, so it can be installed with pkg> add Roots . The package manager looks up where to find the files for Roots in the General Registry and downloads them. The code for Roots now resides in a subdirectory of .julia/packages . Each version of Roots gets its own subdirectory. So you can have several versions installed at the same time. But: Only one version of a package can be loaded at any given time. This can lead to interesting problems... Note that all of the dependencies of Roots were also installed automatically (in this case, Printf and Unicode ). Now we can use all functions that were exported by Roots.jl . For example: help?> find_zero search: find_zero find_zeros find_zero! find_zero(fs, x0, M, [N::AbstractBracketing]; kwargs...) Interface to one of several methods for find zeros of a univariate function. [...] julia> f(x) = exp(x) - x^4; julia> find_zero(f, (8, 9), Bisection()) 8.6131694564414 Closures \u00b6 We encounter a common problem: find_zero expects a one-argument function f(x) . But the function that we use takes 2 arguments: a model and \\(c_T\\) . This type of problem is solved using a closure . A closure is a function that \"captures\" some of the variables in the calling namespace. Example: julia> function foo() x = 1; g(y) = x + y; @show g(2) x = 2; @show g(2) end foo (generic function with 1 method) julia> foo() g(2) = 3 g(2) = 4 Note that g has \"captured\" the variable x from foo . g behaves as if there were an implicit second argument. Anonymous functions \u00b6 When closures are used, they often remain unnamed. Example: julia> findfirst(x -> x > 2, 1:10) 3 # This is the same as julia> f(x) = x > 2; julia> findfirst(f, 1:10) 3 But note: julia> [x -> x^2 for x in (1,2,3)] 3-element Array{var\"#9#11\",1}: #9 (generic function with 1 method) #9 (generic function with 1 method) #9 (generic function with 1 method)","title":"Root Finding"},{"location":"econ890/julia/pih/root_finding.html#root-finding","text":"Root finding means finding the zero of a function, i.e., find \\(x^*\\) such that \\(f(x^*) = 0\\) . For this type of problem, we use code packaged into reusable libraries, called \"packages\". See the Section on Packages . In this case, we will use Roots.jl . Before we can use Roots , we need to add it as a dependency to the current environment : julia> cd(\"/Users/lutz/Documents/data/web/professional/docs/econ890/julia/\") (@v1.5) pkg> activate . Activating new environment at `~/Documents/data/web/professional/docs/econ890/julia/Project.toml` We have now activated the environment described by Project.toml in this directory. To get the Pkg commands to work, type ] and the pkg> prompt appears. Backspace backs out of the Pkg mode in the REPL. To see which packages are already contained in the enviroment: (julia) pkg> st Status `~/Documents/data/web/professional/docs/econ890/julia/Project.toml` (empty project) This makes sense; we have not added any packages yet. But keep in mind that everything we activated before (including all packages in your v1.5 environment are still available). Let's add Roots : (julia) pkg> add Roots Updating registry at `~/.julia/registries/General` ######################################################################## 100.0% Updating registry at `~/.julia/registries/registryLH` Updating git-repo `https://github.com/hendri54/registryLH` Resolving package versions... Updating `~/Documents/data/web/professional/docs/econ890/julia/Project.toml` [f2b01f46] + Roots v1.0.8 Updating `~/Documents/data/web/professional/docs/econ890/julia/Manifest.toml` [f2b01f46] + Roots v1.0.8 [de0858da] + Printf [4ec0a83e] + Unicode (julia) pkg> st Status `~/Documents/data/web/professional/docs/econ890/julia/Project.toml` [f2b01f46] Roots v1.0.8 Now using Roots works. Roots is a registered package, so it can be installed with pkg> add Roots . The package manager looks up where to find the files for Roots in the General Registry and downloads them. The code for Roots now resides in a subdirectory of .julia/packages . Each version of Roots gets its own subdirectory. So you can have several versions installed at the same time. But: Only one version of a package can be loaded at any given time. This can lead to interesting problems... Note that all of the dependencies of Roots were also installed automatically (in this case, Printf and Unicode ). Now we can use all functions that were exported by Roots.jl . For example: help?> find_zero search: find_zero find_zeros find_zero! find_zero(fs, x0, M, [N::AbstractBracketing]; kwargs...) Interface to one of several methods for find zeros of a univariate function. [...] julia> f(x) = exp(x) - x^4; julia> find_zero(f, (8, 9), Bisection()) 8.6131694564414","title":"Root Finding"},{"location":"econ890/julia/pih/root_finding.html#closures","text":"We encounter a common problem: find_zero expects a one-argument function f(x) . But the function that we use takes 2 arguments: a model and \\(c_T\\) . This type of problem is solved using a closure . A closure is a function that \"captures\" some of the variables in the calling namespace. Example: julia> function foo() x = 1; g(y) = x + y; @show g(2) x = 2; @show g(2) end foo (generic function with 1 method) julia> foo() g(2) = 3 g(2) = 4 Note that g has \"captured\" the variable x from foo . g behaves as if there were an implicit second argument.","title":"Closures"},{"location":"econ890/julia/pih/root_finding.html#anonymous-functions","text":"When closures are used, they often remain unnamed. Example: julia> findfirst(x -> x > 2, 1:10) 3 # This is the same as julia> f(x) = x > 2; julia> findfirst(f, 1:10) 3 But note: julia> [x -> x^2 for x in (1,2,3)] 3-element Array{var\"#9#11\",1}: #9 (generic function with 1 method) #9 (generic function with 1 method) #9 (generic function with 1 method)","title":"Anonymous functions"}]}