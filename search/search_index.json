{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"julia_notes/miscellaneous.html","text":"Miscellaneous \u00b6 Good advice on miscellaneous topics: Julia Antipatterns Artifacts (1.6) \u00b6 A useful guide: Artifacts for Dummies Dates (1.6) \u00b6 Working with time durations seems to require converting the durations to millisecond integers first: d1 = DateTime ( 2021 , 9 , 10 , 9 ); d2 = d1 + Minute ( 3 ) + Second ( 5 ); dSeconds = Dates . value ( d2 - d1 ) / 1000 ; Going back to time units requires rounding because Minute(dSeconds) throws an InexactError . dMinutes = Minute ( round ( dSeconds / 60 )); There is no formatted display of durations, only of dates: Dates . format ( d1 , \"HH:MM\" ); Enum (1.6) \u00b6 @enum Fruit apple = 1 orange = 2 kiwi = 3 The type is Fruit (concrete). So dispatch on the instances does not work. The alternative: Defint an abstract type with concrete subtypes Apple <: AbstractFruit . Benefits of enum : Array{Fruit} is more efficient than Array{AbstractFruit} . Benefits of types: Static dispatch. Can be extended. Hashing \u00b6 For new DataType s, it is necessary to defined hash , == , and isequal . hash is needed for containers such as Dict s (it is used for haskey ). The way this is done can be based on AutoHashEquals.jl : mutable struct Foo a :: Int b end Base . hash ( a :: Foo , h :: UInt ) = hash ( a . b , hash ( a . a , hash ( : Foo , h ))) Interpolation (1.6) \u00b6 Interpolations.jl \u00b6 An example from QuantEcon . One limitation: multi-dimensional interpolation only works with unform grids. The inputs must be ranges. The default for extrapolation is to throw an error. Example: xV = 1 : 10 ; yV = 5 : 10 ; zM = xV .+ yV ' .+ xV .* yV ' ; itp = CubicInterpolation (( xV , yV ), zM ); itp ( 1.5 , 5.9 ) The same (?) interpolation can be constructed the long way round: itp2 = interpolate ( zM , BSpline ( Cubic ( Line ( OnGrid ())))); sitp = scale ( itp2 , xV , yV ); One difference is that bounds works on sitp but not on itp . Latex Output (1.6) \u00b6 Latexify.jl renders various expressions as Latex equations. This is useful for automatically making expressions for functional forms. Also generates Latex tables from DataFrames and Arrays . Logging (1.6) \u00b6 @debug can be used to generate self-test code that is only run while developing the code. Example: # test1.jl a = 1 ; b = [ 1 , 2 , 3 ]; @debug begin bSum = sum ( b ); \"\"\" Debug message $bsum \"\"\" end @debug \"Debug with args:\" a , b To run this with the @debug statements enabled, issue (in the shell): export JULIA_DEBUG = all julia \"test1.jl\" But this generates lots of debug messages that sit in Base . To avoid this, export JULIA_DEBUG=MyPkg . Enabling logging levels temporarily: lg = ConsoleLogger ( stderr , Logging . Debug ); with_logger ( lg ) do foo (); end Or: lg = ConsoleLogger ( stderr , Logging . Debug ); old_logger = global_logger ( lg ); foo (); global_logger ( old_logger ); Random numbers (1.5) \u00b6 Generating reproducible random numbers across Julia versions can be done with StableRNGs.jl . This also seems to generate the same random numbers across operating systems (in my case MacOS and Linux). Traits \u00b6 An interesting implementation is WhereTraits.jl which permits, for example, dispatch on functions that return Bool .","title":"Miscellaneous"},{"location":"julia_notes/miscellaneous.html#miscellaneous","text":"Good advice on miscellaneous topics: Julia Antipatterns","title":"Miscellaneous"},{"location":"julia_notes/miscellaneous.html#artifacts-16","text":"A useful guide: Artifacts for Dummies","title":"Artifacts (1.6)"},{"location":"julia_notes/miscellaneous.html#dates-16","text":"Working with time durations seems to require converting the durations to millisecond integers first: d1 = DateTime ( 2021 , 9 , 10 , 9 ); d2 = d1 + Minute ( 3 ) + Second ( 5 ); dSeconds = Dates . value ( d2 - d1 ) / 1000 ; Going back to time units requires rounding because Minute(dSeconds) throws an InexactError . dMinutes = Minute ( round ( dSeconds / 60 )); There is no formatted display of durations, only of dates: Dates . format ( d1 , \"HH:MM\" );","title":"Dates (1.6)"},{"location":"julia_notes/miscellaneous.html#enum-16","text":"@enum Fruit apple = 1 orange = 2 kiwi = 3 The type is Fruit (concrete). So dispatch on the instances does not work. The alternative: Defint an abstract type with concrete subtypes Apple <: AbstractFruit . Benefits of enum : Array{Fruit} is more efficient than Array{AbstractFruit} . Benefits of types: Static dispatch. Can be extended.","title":"Enum (1.6)"},{"location":"julia_notes/miscellaneous.html#hashing","text":"For new DataType s, it is necessary to defined hash , == , and isequal . hash is needed for containers such as Dict s (it is used for haskey ). The way this is done can be based on AutoHashEquals.jl : mutable struct Foo a :: Int b end Base . hash ( a :: Foo , h :: UInt ) = hash ( a . b , hash ( a . a , hash ( : Foo , h )))","title":"Hashing"},{"location":"julia_notes/miscellaneous.html#interpolation-16","text":"","title":"Interpolation (1.6)"},{"location":"julia_notes/miscellaneous.html#interpolationsjl","text":"An example from QuantEcon . One limitation: multi-dimensional interpolation only works with unform grids. The inputs must be ranges. The default for extrapolation is to throw an error. Example: xV = 1 : 10 ; yV = 5 : 10 ; zM = xV .+ yV ' .+ xV .* yV ' ; itp = CubicInterpolation (( xV , yV ), zM ); itp ( 1.5 , 5.9 ) The same (?) interpolation can be constructed the long way round: itp2 = interpolate ( zM , BSpline ( Cubic ( Line ( OnGrid ())))); sitp = scale ( itp2 , xV , yV ); One difference is that bounds works on sitp but not on itp .","title":"Interpolations.jl"},{"location":"julia_notes/miscellaneous.html#latex-output-16","text":"Latexify.jl renders various expressions as Latex equations. This is useful for automatically making expressions for functional forms. Also generates Latex tables from DataFrames and Arrays .","title":"Latex Output (1.6)"},{"location":"julia_notes/miscellaneous.html#logging-16","text":"@debug can be used to generate self-test code that is only run while developing the code. Example: # test1.jl a = 1 ; b = [ 1 , 2 , 3 ]; @debug begin bSum = sum ( b ); \"\"\" Debug message $bsum \"\"\" end @debug \"Debug with args:\" a , b To run this with the @debug statements enabled, issue (in the shell): export JULIA_DEBUG = all julia \"test1.jl\" But this generates lots of debug messages that sit in Base . To avoid this, export JULIA_DEBUG=MyPkg . Enabling logging levels temporarily: lg = ConsoleLogger ( stderr , Logging . Debug ); with_logger ( lg ) do foo (); end Or: lg = ConsoleLogger ( stderr , Logging . Debug ); old_logger = global_logger ( lg ); foo (); global_logger ( old_logger );","title":"Logging (1.6)"},{"location":"julia_notes/miscellaneous.html#random-numbers-15","text":"Generating reproducible random numbers across Julia versions can be done with StableRNGs.jl . This also seems to generate the same random numbers across operating systems (in my case MacOS and Linux).","title":"Random numbers (1.5)"},{"location":"julia_notes/miscellaneous.html#traits","text":"An interesting implementation is WhereTraits.jl which permits, for example, dispatch on functions that return Bool .","title":"Traits"}]}