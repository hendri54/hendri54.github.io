{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"econ890/julia/methods.html","text":"Methods and Multiple Dispatch \u00b6 Now we get to one of the key distinguishing features of Julia: multiple dispatch. Methods \u00b6 When we create a function, we get a strange status message: julia> baz(x) = 2 * x baz (generic function with 1 method) We just created a \"generic function\" (we will pretty much never worry about what that means) with 1 method . But now try julia> function foo end foo (generic function with 0 methods) We just created a function foo with 0 methods . What does this mean? If we try to call foo , we get a MethodError : julia> foo(1) ERROR: MethodError: no method matching foo(::Int64) Now let's define a method : julia> foo(x :: Int) = @show x foo (generic function with 1 method) julia> foo(10) x = 10 And a second one: julia> foo(x :: String) = println(\"$x is a string\") foo (generic function with 2 methods) julia> foo(\"abc\") abc is a string What methods do we have? julia> methods(foo) # 2 methods for generic function \"foo\": [1] foo(x::String) in Main at REPL[4]:1 [2] foo(x::Int64) in Main at REPL[5]:1 So what are functions and methods? A function is just a name. We actually cannot do anything with it. A method specifies what to do when we call foo with a specific set of arguments. Key point: foo(x::Int) and foo(x::String) are not different functions. They are methods of the same function . Multiple Dispatch \u00b6 What do methods do? Methods allow us to execute different code for the same function call, depending on the type of the input argument. julia> foo(1); x = 1 julia> foo(\"abc\"); abc is a string Why do we want this to happen? Benefit 1: We don't have to worry about name conflicts Contrast with Matlab: There can only be one function (and method) named foo . Every time to write a function, you need to create a globally unique name. This makes code reuse very difficult. If two libraries contain a function foo , they cannot both be used at the same time. Benefit 2: Generic programming We can write an algorithm that can handle any type of input object. See below. This is rather similar to object oriented programming where method s are owned by specific objects. The key difference is that, in Julia, this also works with multiple arguments: julia> foo(x,y) = @show x,y foo (generic function with 3 methods) julia> foo(x :: String, y) = println(\"$x is a string, but $y can be anything\") foo (generic function with 4 methods) julia> foo(1,2) (x, y) = (1, 2) (1, 2) julia> foo(\"abc\", 2); abc is a string, but 2 can be anything Notes: We can have methods that have different numbers of arguments (here: 1 or 2). If we have two methods with the same number of arguments, the more specific one is called. foo(x,y) is a fallback method that gets called unless a more specific method exists. Generic Programming \u00b6 Suppose I have written a great sorting algorithm: function mysort(xIn :: Vector{Int}) x = copy(xIn); xSorted = similar(x); xMax = maximum(x) + one(eltype(x)); for j = 1 : length(x) idxMin, xMin = findmin(x); xSorted[j] = xMin; x[j] = xMax; end return xSorted end This is, of course, a terrible algorithm, but it makes clear that I could run this algorithm on any object for which maximum is defined. Wouldn't it be great, if there were a way to remove the restriction that xIn :: Vector{Int} and apply that algorithm to any object for which maximum is defined? That would be especially great, if the user could defined new methods for maximum for any DataType that they might come up with. This is not only possible, it is very common in Julia. Extending existing functions \u00b6 We can extend functions that were defined by others (in modules, including Base ) to new data types. For example, suppose we want to be able to sum String s (this is a bad idea, but we can do it): julia> Base.sum(x :: String, y :: String) = x * \" + \" * y julia> sum(\"a\", \"b\") \"a + b\" Why is this important? Mainly because it enables users to write generic algorithms that can work on any DataType that supports certain functions. The key example is sorting. As long as isless(x,y) is defined, we can sort([x,y,z]) . Contrived example: julia> Base.isless(x :: String, y :: Number) = true julia> sort([3,1,\"a\",4,2]) 5-element Vector{Any}: \"a\" 1 2 3 4 There is a famous talk by Stefan Karpinski called \"The unreasonable effectiveness of multiple dispatch\" which explains why this is so powerful.","title":"Methods and Multiple Dispatch"},{"location":"econ890/julia/methods.html#methods-and-multiple-dispatch","text":"Now we get to one of the key distinguishing features of Julia: multiple dispatch.","title":"Methods and Multiple Dispatch"},{"location":"econ890/julia/methods.html#methods","text":"When we create a function, we get a strange status message: julia> baz(x) = 2 * x baz (generic function with 1 method) We just created a \"generic function\" (we will pretty much never worry about what that means) with 1 method . But now try julia> function foo end foo (generic function with 0 methods) We just created a function foo with 0 methods . What does this mean? If we try to call foo , we get a MethodError : julia> foo(1) ERROR: MethodError: no method matching foo(::Int64) Now let's define a method : julia> foo(x :: Int) = @show x foo (generic function with 1 method) julia> foo(10) x = 10 And a second one: julia> foo(x :: String) = println(\"$x is a string\") foo (generic function with 2 methods) julia> foo(\"abc\") abc is a string What methods do we have? julia> methods(foo) # 2 methods for generic function \"foo\": [1] foo(x::String) in Main at REPL[4]:1 [2] foo(x::Int64) in Main at REPL[5]:1 So what are functions and methods? A function is just a name. We actually cannot do anything with it. A method specifies what to do when we call foo with a specific set of arguments. Key point: foo(x::Int) and foo(x::String) are not different functions. They are methods of the same function .","title":"Methods"},{"location":"econ890/julia/methods.html#multiple-dispatch","text":"What do methods do? Methods allow us to execute different code for the same function call, depending on the type of the input argument. julia> foo(1); x = 1 julia> foo(\"abc\"); abc is a string Why do we want this to happen? Benefit 1: We don't have to worry about name conflicts Contrast with Matlab: There can only be one function (and method) named foo . Every time to write a function, you need to create a globally unique name. This makes code reuse very difficult. If two libraries contain a function foo , they cannot both be used at the same time. Benefit 2: Generic programming We can write an algorithm that can handle any type of input object. See below. This is rather similar to object oriented programming where method s are owned by specific objects. The key difference is that, in Julia, this also works with multiple arguments: julia> foo(x,y) = @show x,y foo (generic function with 3 methods) julia> foo(x :: String, y) = println(\"$x is a string, but $y can be anything\") foo (generic function with 4 methods) julia> foo(1,2) (x, y) = (1, 2) (1, 2) julia> foo(\"abc\", 2); abc is a string, but 2 can be anything Notes: We can have methods that have different numbers of arguments (here: 1 or 2). If we have two methods with the same number of arguments, the more specific one is called. foo(x,y) is a fallback method that gets called unless a more specific method exists.","title":"Multiple Dispatch"},{"location":"econ890/julia/methods.html#generic-programming","text":"Suppose I have written a great sorting algorithm: function mysort(xIn :: Vector{Int}) x = copy(xIn); xSorted = similar(x); xMax = maximum(x) + one(eltype(x)); for j = 1 : length(x) idxMin, xMin = findmin(x); xSorted[j] = xMin; x[j] = xMax; end return xSorted end This is, of course, a terrible algorithm, but it makes clear that I could run this algorithm on any object for which maximum is defined. Wouldn't it be great, if there were a way to remove the restriction that xIn :: Vector{Int} and apply that algorithm to any object for which maximum is defined? That would be especially great, if the user could defined new methods for maximum for any DataType that they might come up with. This is not only possible, it is very common in Julia.","title":"Generic Programming"},{"location":"econ890/julia/methods.html#extending-existing-functions","text":"We can extend functions that were defined by others (in modules, including Base ) to new data types. For example, suppose we want to be able to sum String s (this is a bad idea, but we can do it): julia> Base.sum(x :: String, y :: String) = x * \" + \" * y julia> sum(\"a\", \"b\") \"a + b\" Why is this important? Mainly because it enables users to write generic algorithms that can work on any DataType that supports certain functions. The key example is sorting. As long as isless(x,y) is defined, we can sort([x,y,z]) . Contrived example: julia> Base.isless(x :: String, y :: Number) = true julia> sort([3,1,\"a\",4,2]) 5-element Vector{Any}: \"a\" 1 2 3 4 There is a famous talk by Stefan Karpinski called \"The unreasonable effectiveness of multiple dispatch\" which explains why this is so powerful.","title":"Extending existing functions"}]}