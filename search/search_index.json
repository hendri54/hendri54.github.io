{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"econ890/julia/methods.html","text":"Methods and Multiple Dispatch \u00b6 Methods \u00b6 julia> function foo end foo (generic function with 0 methods) We just created a function foo with 0 methods . What does this mean? If we try to call foo , we get a MethodError : julia> foo(1) ERROR: MethodError: no method matching foo(::Int64) Now let's define a method : julia> foo(x :: Int) = @show x foo (generic function with 1 method) And a second one: julia> foo(x :: String) = println(\"$x is a string\") foo (generic function with 2 methods) What methods do we have? julia> methods(foo) # 2 methods for generic function \"foo\": [1] foo(x::String) in Main at REPL[4]:1 [2] foo(x::Int64) in Main at REPL[5]:1 A function is just a name. A method specifies what to do when we call foo with a specific set of arguments. Multiple Dispatch \u00b6 We can have the same function call foo(x) execute different code, depending on the argument type: julia> foo(1); x = 1 julia> foo(\"abc\"); abc is a string This is rather similar to object oriented programming where method s are owned by specific objects. The key difference is that, in Julia, this also works with multiple arguments: julia> foo(x,y) = @show x,y foo (generic function with 3 methods) julia> foo(x :: String, y) = println(\"$x is a string, but $y can be anything\") foo (generic function with 4 methods) julia> foo(1,2) (x, y) = (1, 2) (1, 2) julia> foo(\"abc\", 2); abc is a string, but 2 can be anything Notes: We can have methods that have different numbers of arguments (here: 1 or 2). If we have two methods with the same number of arguments, the more specific one is called. foo(x,y) is a fallback method that gets called unless a more specific method exists. Extending existing functions \u00b6 We can extend functions that were defined by others (in modules, including Base ) to new data types. For example, suppose we want to be able to sum String s (this is a bad idea, but we can do it): julia> Base.sum(x :: String, y :: String) = x * \" + \" * y julia> sum(\"a\", \"b\") \"a + b\" Why is this important? Mainly because it enables users to write generic algorithms that can work on any DataType that supports certain functions. The key example is sorting. As long as isless(x,y) is defined, we can sort([x,y,z]) . Contrived example: julia> Base.isless(x :: String, y :: Number) = true julia> sort([3,1,\"a\",4,2]) 5-element Vector{Any}: \"a\" 1 2 3 4 There is a famous talk by Stefan Karpinski called \"The unreasonable effectiveness of multiple dispatch\" which explains why this is so powerful.","title":"Methods and Multiple Dispatch"},{"location":"econ890/julia/methods.html#methods-and-multiple-dispatch","text":"","title":"Methods and Multiple Dispatch"},{"location":"econ890/julia/methods.html#methods","text":"julia> function foo end foo (generic function with 0 methods) We just created a function foo with 0 methods . What does this mean? If we try to call foo , we get a MethodError : julia> foo(1) ERROR: MethodError: no method matching foo(::Int64) Now let's define a method : julia> foo(x :: Int) = @show x foo (generic function with 1 method) And a second one: julia> foo(x :: String) = println(\"$x is a string\") foo (generic function with 2 methods) What methods do we have? julia> methods(foo) # 2 methods for generic function \"foo\": [1] foo(x::String) in Main at REPL[4]:1 [2] foo(x::Int64) in Main at REPL[5]:1 A function is just a name. A method specifies what to do when we call foo with a specific set of arguments.","title":"Methods"},{"location":"econ890/julia/methods.html#multiple-dispatch","text":"We can have the same function call foo(x) execute different code, depending on the argument type: julia> foo(1); x = 1 julia> foo(\"abc\"); abc is a string This is rather similar to object oriented programming where method s are owned by specific objects. The key difference is that, in Julia, this also works with multiple arguments: julia> foo(x,y) = @show x,y foo (generic function with 3 methods) julia> foo(x :: String, y) = println(\"$x is a string, but $y can be anything\") foo (generic function with 4 methods) julia> foo(1,2) (x, y) = (1, 2) (1, 2) julia> foo(\"abc\", 2); abc is a string, but 2 can be anything Notes: We can have methods that have different numbers of arguments (here: 1 or 2). If we have two methods with the same number of arguments, the more specific one is called. foo(x,y) is a fallback method that gets called unless a more specific method exists.","title":"Multiple Dispatch"},{"location":"econ890/julia/methods.html#extending-existing-functions","text":"We can extend functions that were defined by others (in modules, including Base ) to new data types. For example, suppose we want to be able to sum String s (this is a bad idea, but we can do it): julia> Base.sum(x :: String, y :: String) = x * \" + \" * y julia> sum(\"a\", \"b\") \"a + b\" Why is this important? Mainly because it enables users to write generic algorithms that can work on any DataType that supports certain functions. The key example is sorting. As long as isless(x,y) is defined, we can sort([x,y,z]) . Contrived example: julia> Base.isless(x :: String, y :: Number) = true julia> sort([3,1,\"a\",4,2]) 5-element Vector{Any}: \"a\" 1 2 3 4 There is a famous talk by Stefan Karpinski called \"The unreasonable effectiveness of multiple dispatch\" which explains why this is so powerful.","title":"Extending existing functions"},{"location":"econ890/julia/outline.html","text":"Julia for Economists \u00b6 Our approach will be to compute a version of the classic Huggett (1996) model. We will start simple, but eventually (time permitting) get to the point where our code will be well structured, reusable, and tested. Table of Contents \u00b6 Basics \u00b6 Getting started Types and variables Arrays Functions Methods and multiple dispatch User defined types Writing solid code Object oriented programming Packages Testing Debugging Solving a Permanent Income Model \u00b6 Simple minded approach OOP approach Shooting approach Policy function iteration","title":"Julia for Economists"},{"location":"econ890/julia/outline.html#julia-for-economists","text":"Our approach will be to compute a version of the classic Huggett (1996) model. We will start simple, but eventually (time permitting) get to the point where our code will be well structured, reusable, and tested.","title":"Julia for Economists"},{"location":"econ890/julia/outline.html#table-of-contents","text":"","title":"Table of Contents"},{"location":"econ890/julia/outline.html#basics","text":"Getting started Types and variables Arrays Functions Methods and multiple dispatch User defined types Writing solid code Object oriented programming Packages Testing Debugging","title":"Basics"},{"location":"econ890/julia/outline.html#solving-a-permanent-income-model","text":"Simple minded approach OOP approach Shooting approach Policy function iteration","title":"Solving a Permanent Income Model"}]}