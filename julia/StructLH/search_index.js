var documenterSearchIndex = {"docs":
[{"location":"index.html#StructLH-Documentation","page":"StructLH Documentation","title":"StructLH Documentation","text":"","category":"section"},{"location":"index.html","page":"StructLH Documentation","title":"StructLH Documentation","text":"Code for manipulating structs.","category":"page"},{"location":"index.html#Helpers","page":"StructLH Documentation","title":"Helpers","text":"","category":"section"},{"location":"index.html","page":"StructLH Documentation","title":"StructLH Documentation","text":"@common_fields\nretrieve_property\nretrieve_child_property\nhas_property","category":"page"},{"location":"index.html#StructLH.@common_fields","page":"StructLH Documentation","title":"StructLH.@common_fields","text":"Macro to set common fields in structs. See https://discourse.julialang.org/t/julia-learning-macros-metaprogramming/45753/3\n\nExample\n\n@common_fields set1 begin\n    x :: Int\n    y :: Float64\nend\n\nstruct Foo\n    @set1\n    z\nend\n\n\n\n\n\n","category":"macro"},{"location":"index.html#StructLH.retrieve_property","page":"StructLH Documentation","title":"StructLH.retrieve_property","text":"retrieve_property(o, pName)\n\n\nRetrieve a property from an object or its child objects. If the property is not unique, returns the first match and then stops. Returns nothing if not found.\n\n\n\n\n\n","category":"function"},{"location":"index.html#StructLH.retrieve_child_property","page":"StructLH Documentation","title":"StructLH.retrieve_child_property","text":"retrieve_child_property(o, childName, pName)\n\n\nRetrieve a property in a child object of a given name. Does not retrieve property from object itself. This helps when properties are not unique.\n\n\n\n\n\n","category":"function"},{"location":"index.html#StructLH.has_property","page":"StructLH Documentation","title":"StructLH.has_property","text":"has_property(o, pName)\n\n\nDoes object or a child object have a property?\n\n\n\n\n\n","category":"function"},{"location":"index.html#Merging-objects","page":"StructLH Documentation","title":"Merging objects","text":"","category":"section"},{"location":"index.html","page":"StructLH Documentation","title":"StructLH Documentation","text":"merge_object_arrays!\nreduce_object_vector","category":"page"},{"location":"index.html#StructLH.merge_object_arrays!","page":"StructLH Documentation","title":"StructLH.merge_object_arrays!","text":"merge_object_arrays!\n\nMerge all arrays (and vectors) from object oSource into the corresponding arrays in another object oTg (at given index values idxV). If target does not have corresponding field: behavior is governed by skipMissingFields.\n\nArguments\n\nidxV   Vector{Integer} or other iterable with integer results. Indexes the first dimension of each object to be copied.   The assignment is: oSource.x[i1,:] => oTg.x[idxV[i1],:].\n\n\n\n\n\n","category":"function"},{"location":"index.html#StructLH.reduce_object_vector","page":"StructLH Documentation","title":"StructLH.reduce_object_vector","text":"reduce_object_vector(oVecV, reduceFct; fieldTypes)\n\n\nGiven a vector of mutable structs, compute a function of all numeric fields. Immutable structs are skipped.\n\nExample use case: Compute the mean and standard deviation of simulated model statistics.\n\nreduceFct takes a vector of numeric inputs and returns a single numeric output that is of compatible size and type so it can be written back into an instance of the objects contained in oVecV.\n\nTo handle Nan or missing, make sure that reduceFct appropriately handles or skips them.\n\nOptional input fieldTypes indicates which non-numeric field types to use as well.\n\nLimitation: Because the output object is of the same type as the input objects in oVecV, it is not possible to apply reduceFct that returns a different type from its inputs. For example, mean of integers does not work.\n\nChange: exclude immutable fields, but keep scalars (which are immutable but can be changed!) +++\n\n\n\n\n\n","category":"function"},{"location":"index.html#Traversing-objects","page":"StructLH Documentation","title":"Traversing objects","text":"","category":"section"},{"location":"index.html","page":"StructLH Documentation","title":"StructLH Documentation","text":"apply_fct_to_object traverses an object and applies a function to each property. The results are stored in ApplyFctResult.","category":"page"},{"location":"index.html","page":"StructLH Documentation","title":"StructLH Documentation","text":"apply_fct_to_object\nApplyFctResult\nobj_name\nobj_type\nfct_value\nchildren","category":"page"},{"location":"index.html#StructLH.apply_fct_to_object","page":"StructLH Documentation","title":"StructLH.apply_fct_to_object","text":"apply_fct_to_object(x, xName, f)\n\n\nApply function f to all properties of an object and its children. Stop parsing child objects if continue_parsing(x) == false. Return tuple with\n\nname of object\ntype of object\nreturn value of f\nentries for children\n\nBeware: Some functions, such as sum, have fallback methods that apply to Any. That leads to crashes.\n\n\n\n\n\n","category":"function"},{"location":"index.html#StructLH.ApplyFctResult","page":"StructLH Documentation","title":"StructLH.ApplyFctResult","text":"Object that holds result from traversing an object and applying a function to each property.\n\n\n\n\n\n","category":"type"},{"location":"index.html#StructLH.obj_name","page":"StructLH Documentation","title":"StructLH.obj_name","text":"obj_name(x)\n\n\nName of object.\n\n\n\n\n\n","category":"function"},{"location":"index.html#StructLH.obj_type","page":"StructLH Documentation","title":"StructLH.obj_type","text":"obj_type(x)\n\n\nType of object.\n\n\n\n\n\n","category":"function"},{"location":"index.html#StructLH.fct_value","page":"StructLH Documentation","title":"StructLH.fct_value","text":"fct_value(x)\n\n\nFunction value or nothing.\n\n\n\n\n\n","category":"function"},{"location":"index.html#StructLH.children","page":"StructLH Documentation","title":"StructLH.children","text":"children(x)\n\n\nChild objects, excluding those that contain no function values (themselves, or their children).\n\n\n\n\n\n","category":"function"},{"location":"index.html","page":"StructLH Documentation","title":"StructLH Documentation","text":"The structure of an object and its children can be summarized with one call to describe.","category":"page"},{"location":"index.html","page":"StructLH Documentation","title":"StructLH Documentation","text":"describe\ndescribe_object\nshow_description","category":"page"},{"location":"index.html#StructLH.describe","page":"StructLH Documentation","title":"StructLH.describe","text":"describe(x)\n\n\nReturns a description for an object. Nothing is the default.\n\n\n\n\n\n","category":"function"},{"location":"index.html#StructLH.describe_object","page":"StructLH Documentation","title":"StructLH.describe_object","text":"describe_object(x)\n\n\nDescribe an object and its children. Recursively calls describe and returns a vector of strings.\n\nThe default return value for describe is nothing. Then the object is not displayed. Otherwise, the return is passed through format_describe for formatting.\n\n\n\n\n\n","category":"function"},{"location":"index.html#StructLH.show_description","page":"StructLH Documentation","title":"StructLH.show_description","text":"show_description(io, x)\n\n\nWrite object description to IO.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Converting-to-Dicts","page":"StructLH Documentation","title":"Converting to Dicts","text":"","category":"section"},{"location":"index.html","page":"StructLH Documentation","title":"StructLH Documentation","text":"The main purpose is to make it easier to serialize user defined types. ","category":"page"},{"location":"index.html","page":"StructLH Documentation","title":"StructLH Documentation","text":"NodeInfo\nstruct2dict\ndict2struct!","category":"page"},{"location":"index.html#StructLH.NodeInfo","page":"StructLH Documentation","title":"StructLH.NodeInfo","text":"Struct that contains information about one node in the Dict created by struct2dict.\n\n\n\n\n\n","category":"type"},{"location":"index.html#StructLH.struct2dict","page":"StructLH Documentation","title":"StructLH.struct2dict","text":"struct2dict(s)\n\n\nConvert a struct to a nested Dict. Known leaf types, such as strings, arrays become NodeInfo entries in the Dict. structs become their own Dicts.\n\nThe purpose is to convert a struct into a Dict of simple \"built-in\" types that can be serialized. Each leaf entry contains information about the DataType of the leaf, so that the object can be reconstructed. In case the data are saved to a format that does not preserve size information, the size of the object is also saved.\n\n\n\n\n\n","category":"function"},{"location":"index.html#StructLH.dict2struct!","page":"StructLH Documentation","title":"StructLH.dict2struct!","text":"dict2struct!(s, d)\n\n\nThe inverse of struct2dict. Takes a fully initialized MUTABLE struct as input. Copies the values from the Dict into the struct. Mismatches between Dict keys and propertynames(s) are ignored. That means: fields that are missing from the Dict are not initialized. Extra fields in the Dict are ignored.\n\n\n\n\n\n","category":"function"},{"location":"index.html","page":"StructLH Documentation","title":"StructLH Documentation","text":"","category":"page"}]
}
